// Generated by CoffeeScript 1.7.1
(function() {
  var arg, codejam, exports, i, input, numthreads, parallelsolve, parse, solve, _i, _len, _ref;

  input = require('./input.js');

  parse = require('./parse.js');

  solve = function(format, callback, handle, debug) {
    var jam, k, readerList;
    if (handle == null) {
      handle = null;
    }
    if (debug == null) {
      debug = false;
    }
    debug = !!debug;
    jam = {
      print: function(data) {
        return process.stdout.write("" + data);
      },
      debug: function(data) {
        if (debug) {
          return process.stderr.write("" + data + "\n");
        }
      }
    };
    if (handle != null) {
      for (k in jam) {
        handle[k] = jam[k];
      }
    }
    readerList = parse(format);
    return input("_NC,cases:{" + format + "}[_NC]", function(_NC, cases) {
      var args, i, j, onecase, _i, _j, _ref;
      for (i = _i = 0; 0 <= _NC ? _i < _NC : _i > _NC; i = 0 <= _NC ? ++_i : --_i) {
        jam.print("Case #" + (i + 1) + ": ");
        if (debug) {
          jam.debug("DEBUG for Case #" + (i + 1) + ":");
        }
        onecase = cases[i];
        args = [];
        for (j = _j = 0, _ref = readerList.length; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
          args.push(onecase[readerList[j].name]);
        }
        callback.apply(jam, args);
        jam.print('\n');
      }
      process.stdin.removeAllListeners();
      return process.stdin.destroy();
    });
  };

  parallelsolve = function(threads, format, callback, debug) {
    var Parallel, readerList, x;
    if (debug == null) {
      debug = false;
    }
    Parallel = require('paralleljs');
    debug = !!debug;
    readerList = (function() {
      var _i, _len, _ref, _results;
      _ref = parse(format);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(x.name);
      }
      return _results;
    })();
    return input("_NC,cases:{" + format + "}[_NC]", function(_NC, cases) {
      var c, name;
      cases = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = cases.length; _i < _len; _i++) {
          c = cases[_i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = readerList.length; _j < _len1; _j++) {
              name = readerList[_j];
              _results1.push(c[name]);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      new Parallel(cases, {
        maxWorkers: threads
      }).require({
        fn: callback,
        name: 'codejamCallback'
      }).map(function(data) {
        var jam, stderr, stdout;
        stdout = '';
        stderr = '';
        jam = {
          print: function(data) {
            return stdout += "" + data;
          },
          debug: function(data) {
            return stderr += "" + data + "\n";
          }
        };
        codejamCallback.apply(jam, data);
        jam.print('\n');
        return [stdout, stderr];
      }).then(function(output) {
        var err, i, out, _i, _len, _ref, _results;
        _results = [];
        for (i = _i = 0, _len = output.length; _i < _len; i = ++_i) {
          _ref = output[i], out = _ref[0], err = _ref[1];
          process.stdout.write("Case #" + (i + 1) + ": " + out);
          if (debug) {
            _results.push(process.stdout.write("DEBUG for Case #" + (i + 1) + ":\n" + err));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      process.stdin.removeAllListeners();
      return process.stdin.destroy();
    });
  };

  codejam = function(format, callback, debug) {
    return solve(format, callback, debug);
  };

  codejam.parallel = parallelsolve;

  _ref = process.argv;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    arg = _ref[i];
    if (arg === '-j') {
      numthreads = parseInt(process.argv[i + 1]);
      codejam = function(format, callback, debug) {
        return parallelsolve(numthreads, format, callback, debug);
      };
    }
  }

  module.exports = exports = codejam;

}).call(this);

//# sourceMappingURL=codejam.map
